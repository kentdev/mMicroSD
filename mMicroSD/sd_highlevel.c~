#include "sd_highlevel.h"

#ifdef DEBUG
#include "m_usb.h"


const char reducing_spi[] PROGMEM = "Reducing SPI speed: ";
const char spi_2mhz[] PROGMEM = "2 MHz\n";
const char spi_1mhz[] PROGMEM = "1 MHz\n";
const char spi_500khz[] PROGMEM = "500 kHz\n";
const char spi_slow[] PROGMEM = "Too slow\n";

const char recovery_start[] PROGMEM = "ERROR RECOVERY\n";
const char recovery_success[] PROGMEM = "RECOVERY OK\n";
const char recovery_fail[] PROGMEM = "RECOVERY FAILED\n";

void debug_message (const char *pgm_message)
{
    print_P (pgm_message);
}

#endif

uint8_t error_code;



bool initialized = false;

bool block_cached = false;

#ifdef WRITECACHE
bool write_pending = false;
#endif

uint32_t cached_block_num;

enum spi_speed current_speed;
crc_option current_crc_type;

bool drop_speed (void)
{
    #ifdef DEBUG
    debug_message (reducing_spi);
    #endif
    
    switch (current_speed)
    {
        case SPI_HIGH_SPEED:
            current_speed = SPI_MED_SPEED;
            #ifdef DEBUG
            debug_message (spi_2mhz);
            #endif
            break;
        case SPI_MED_SPEED:
            current_speed = SPI_LOW_SPEED;
            #ifdef DEBUG
            debug_message (spi_1mhz);
            #endif
            break;
        case SPI_LOW_SPEED:
            current_speed = SPI_MIN_SPEED;
            #ifdef DEBUG
            debug_message (spi_500khz);
            #endif
            break;
        case SPI_MIN_SPEED:
        case SPI_INIT_SPEED:
            #ifdef DEBUG
            debug_message (spi_slow);
            #endif
            return false;
    }
    
    start_spi (current_speed);
    return true;
}


// if a read or write fails due to an unknown error, try reducing the speed
// and re-initializing the card
bool error_recovery (void)
{
    #ifdef DEBUG
    debug_message (recovery_start);
    #endif
    
    attempt_resync();
    if (!drop_speed())
        return false;
    attempt_resync();
    
    enum spi_speed lower_speed = current_speed;
    
    if (!init_card (current_crc_type))
    {
        #ifdef DEBUG
        debug_message (recovery_success);
        #endif
        return false;
    }
    
    attempt_resync();
    
    current_speed = lower_speed;
    
    #ifdef DEBUG
    debug_message (recovery_fail);
    #endif
    
    return true;
}


bool init_card (crc_option crc_type)
{
    uint8_t test = 0;
    
    current_crc_type = crc_type;
    
    start_spi (SPI_INIT_SPEED);
    
    if (reset_card() != OK)
    {
        error_code = ERROR_RESET;
        return false;
    }
    
    if (crc_type == USE_CRC)
    {
        if (enable_crc() != OK)
        {
            error_code = ERROR_ENABLE_CRC;
            return false;
        }
    }
    
    if (initialize_card() != OK)
    {
        error_code = ERROR_INIT;
        return false;
    }
    
    if (set_block_length (512) != OK)
    {
        error_code = ERROR_BLOCK_LENGTH;
        return false;
    }
    
    initialized = true;
    
    // start at the minimum speed and check if this card actually supports CRC
    start_spi (SPI_MIN_SPEED);
    if (crc_type == USE_CRC)
    {
        if (!read_partial_block (0, 0, &test, 1))
        {
            if (error_code == ERROR_CRC && last_crc == 0xffff)
            {  // this card isn't giving us valid CRCs after all
                error_code = ERROR_ENABLE_CRC;
            }
            
            // Either it doesn't support CRC when we want it to, or
            // it doesn't even get up to 1MHz.  Either way, FAIL.
            return false;
        }
    }
    
    // bump the speed up to max
    current_speed = SPI_HIGH_SPEED;
    start_spi (SPI_HIGH_SPEED);
    
    error_code = ERROR_NONE;
    return true;
}



// reads an entire block into block[]
// intended for use only by read_partial_block and write_partial_block
bool read_whole_block (const uint32_t block_number)
{
    uint8_t crc_retries = CRC_RETRIES;
    uint8_t timeout_retries = TIMEOUT_RETRIES;
    uint8_t unknown_retries = UNKNOWN_RETRIES;    
    
    ret status;
read:
    if (block_cached && cached_block_num == block_number)
        status = OK;
    else
        status = read_block (block_number);
    
    switch (status)
    {
        case OK:
            break;
        case BAD_CRC:
            if (crc_retries > 0)
            {
                crc_retries--;
                goto read;
            }
            else
            {
                error_code = ERROR_CRC;
                return false;
            }
            break;
        case TIMEOUT:
            if (timeout_retries > 0)
            {
                timeout_retries--;
                goto read;
            }
            else
            {
                error_code = ERROR_TIMEOUT;
                return false;
            }
            break;
        default:
            if (unknown_retries > 0)
            {
                unknown_retries--;
                goto read;
            }
            else
            {
                if (error_recovery())
                {  // if we were able to lower the speed and re-initialize the card
                    unknown_retries = UNKNOWN_RETRIES;
                    goto read;
                }
                else
                {
                    error_code = ERROR_UNKNOWN;
                    return false;
                }
            }
            break;
    }
    
    block_cached = true;
    cached_block_num = block_number;
    
    error_code = ERROR_NONE;
    return true;
}




// reads data, blocks are 512 bytes long
//
// the most recently read block is cached, so reading different parts of the
// same block over multiple calls doesn't have much of a performance penalty
bool read_partial_block (const uint32_t block_number,
                         const uint16_t offset,
                         uint8_t *buffer,
                         const uint16_t length)
{
    if (!initialized)
    {
        error_code = ERROR_CARD_UNINIT;
        return false;
    }
    
    if (buffer == 0)
    {
        error_code = ERROR_NULL_BUFFER;
        return false;
    }
    
    #ifdef WRITECACHE
    if (write_pending && block_cached && (cached_block_num != block_number || buffer == 0))
    {  // if there's a write pending for a different block, we need to do that first
        #ifdef DEBUG
        m_usb_tx_string ("read forced commit: ");
        m_usb_tx_ulong (cached_block_num);
        m_usb_tx_string ("VS new ");
        m_usb_tx_ulong (block_number);
        m_usb_tx_string ("\n");
        #endif
        
        if (!write_commit())
            return false;
    }
    #endif
    
    if (offset + length > 512)
    {
        error_code = ERROR_TOO_FAR;
        return false;
    }
    
    if (!read_whole_block (block_number))
        return false;
    
    // copy the relevant bytes from the block to the buffer
    for (uint16_t i = 0; i < length; i++)
        buffer[i] = block[offset + i];
    
    error_code = ERROR_NONE;
    return true;
}


// reads a block's CRC value without touching block[]
// is not affected by caching
bool read_block_crc (const uint32_t block_number,
                     uint16_t *crc)
{
    if (!initialized)
    {
        error_code = ERROR_CARD_UNINIT;
        return false;
    }
    
    uint8_t crc_retries = CRC_RETRIES;
    uint8_t timeout_retries = TIMEOUT_RETRIES;
    uint8_t unknown_retries = UNKNOWN_RETRIES;    
    
    ret status;
read:
    status = read_block_crc_only (block_number, crc);
    
    switch (status)
    {
        case OK:
            break;
        case BAD_CRC:
            if (crc_retries > 0)
            {
                crc_retries--;
                goto read;
            }
            else
            {
                error_code = ERROR_CRC;
                return false;
            }
            break;
        case TIMEOUT:
            if (timeout_retries > 0)
            {
                timeout_retries--;
                goto read;
            }
            else
            {
                error_code = ERROR_TIMEOUT;
                return false;
            }
            break;
        default:
            if (unknown_retries > 0)
            {
                unknown_retries--;
                goto read;
            }
            else
            {
                if (error_recovery())
                {  // if we were able to lower the speed and re-initialize the card
                    unknown_retries = UNKNOWN_RETRIES;
                    goto read;
                }
                else
                {
                    error_code = ERROR_UNKNOWN;
                    return false;
                }
            }
            break;
    }
    
    error_code = ERROR_NONE;
    return true;
}





// writes data to a block
//
// if not writing the entire block, then the write might not happen immediately
// so that several small writes can be grouped into a single larger write
bool write_partial_block (const uint32_t block_number,
                          const uint16_t offset,
                          const uint8_t *buffer,
                          const uint16_t length)
{
    if (!initialized)
    {
        error_code = ERROR_CARD_UNINIT;
        return false;
    }
    
    if (buffer == 0)
    {
        error_code = ERROR_NULL_BUFFER;
        return false;
    }
    
    if (offset + length > 512)
    {
        #ifdef DEBUG
        m_usb_tx_string ("TOO FAR: offset = ");
        m_usb_tx_uint (offset);
        m_usb_tx_string (", length = ");
        m_usb_tx_uint (length);
        m_usb_tx_char ('\n');
        #endif
        
        error_code = ERROR_TOO_FAR;
        return false;
    }
    
    #ifdef FREE_RAM
    free_ram();
    #endif
    
    #ifdef WRITECACHE
    if (write_pending && (cached_block_num != block_number))
    {  // if there's a write to a different block still pending
        #ifdef DEBUG
        m_usb_tx_string ("write forced commit: ");
        m_usb_tx_ulong (cached_block_num);
        m_usb_tx_string ("VS new ");
        m_usb_tx_ulong (block_number);
        m_usb_tx_string ("\n");
        #endif
        
        if (!write_commit())
            return false;
    }
    #endif
    
    // if we don't have this block in memory
    if (!block_cached || (cached_block_num != block_number))
    {
        // read the whole block in first
        if (!read_whole_block (block_number))
            return false;
    }
    
    // modify the block using the input buffer
    #ifdef DEBUG
    m_usb_tx_string ("Writing to ");
    m_usb_tx_ulong (block_number);
    m_usb_tx_string (", offset ");
    m_usb_tx_hex (offset);
    m_usb_tx_string (": ");
    #endif
    for (uint16_t i = 0; i < length; i++)
    {
        block[offset + i] = buffer[i];
        
        #ifdef DEBUG
        m_usb_tx_hexchar (block[offset + i]);
        m_usb_tx_char (' ');
        #endif
    }
    #ifdef DEBUG
    m_usb_tx_char ('\n');
    #endif
    
    
    block_cached = true;
    cached_block_num = block_number;
    
    
    #ifdef WRITECACHE
    
    #ifdef DEBUG
    m_usb_tx_string ("Deferring write to block ");
    m_usb_tx_ulong (block_number);
    m_usb_tx_string ("\n");
    #endif
    
    // don't do the actual write yet
    write_pending = true;
    error_code = ERROR_NONE;
    
    #else
    
    if (!write_commit())
        return false;
    
    #endif
    
    return true;
}


// flush any cached writes to the SD card
//
// the block is marked as cached after writing, since block will
// contain the same contents as the sector on the SD card
bool write_commit (void)
{
    #ifdef WRITECACHE
    if (!write_pending)
    {
        error_code = ERROR_NONE;
        return true;  // nothing to write
    }
    
    #ifdef DEBUG
    m_usb_tx_string ("Committing write to block ");
    m_usb_tx_ulong (cached_block_num);
    m_usb_tx_string ("\n");
    #endif
    #endif
    
    uint8_t crc_retries = CRC_RETRIES;
    uint8_t timeout_retries = TIMEOUT_RETRIES;
    uint8_t unknown_retries = UNKNOWN_RETRIES;
    
    // write the whole block to the card
    ret status;
write:
    status = write_block (cached_block_num);
    
    switch (status)
    {
        case OK:
            break;
        case BAD_CRC:
            if (crc_retries > 0)
            {
                crc_retries--;
                goto write;
            }
            else
            {
                error_code = ERROR_CRC;
                return false;
            }
            break;
        case TIMEOUT:
            if (timeout_retries > 0)
            {
                timeout_retries--;
                goto write;
            }
            else
            {
                error_code = ERROR_TIMEOUT;
                return false;
            }
            break;
        default:
            if (unknown_retries > 0)
            {
                unknown_retries--;
                goto write;
            }
            else
            {
                if (error_recovery())
                {  // if we were able to lower the speed and re-initialize the card
                    unknown_retries = UNKNOWN_RETRIES;
                    goto write;
                }
                else
                {
                    error_code = ERROR_UNKNOWN;
                    return false;
                }
            }
            break;
    }
    
    #ifdef VERIFY_WRITE
    #ifdef DEBUG
    m_usb_tx_string ("WRITE VERIFICATION\n");
    #endif
    
    uint16_t written_crc = crc16_ccitt (block, block_length);
    uint16_t returned_crc;
    if (!read_block_crc (cached_block_num, &returned_crc))
        return false;
    
    if (written_crc != returned_crc)
    {
        #ifdef DEBUG
        m_usb_tx_string ("\nWRITE VERIFICATION FAILED\n");
        m_usb_tx_string ("Write CRC: ");
        m_usb_tx_hex (written_crc);
        m_usb_tx_string (", read CRC: ");
        m_usb_tx_hex (returned_crc);
        m_usb_tx_string ("\n");
        #endif
        
        if (crc_retries > 0)
        {
            crc_retries--;
            goto write;
        }
        else
        {
            error_code = ERROR_CRC;
            return false;
        }
    }
    
    #ifdef DEBUG
    m_usb_tx_string ("\nWRITE VERIFICATION OK\n");
    #endif
    
    #endif
    
    
    #ifdef WRITECACHE
    write_pending = false;
    #endif
    block_cached = true;
    
    error_code = ERROR_NONE;
    return true;
}

