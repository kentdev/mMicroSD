#include <stdint.h>
#include <avr/io.h>
#include <avr/pgmspace.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include <util/twi.h>

#include "sd_fat32.h"

#define I2C_ADDR (0x5D)
#define TWI_BUFFER_LEN 64

// This code is designed to run on the ATmega168 or ATmega328, not the M2

#define set(reg,bit)		reg |= (1<<(bit))
#define clear(reg,bit)		reg &= ~(1<<(bit))
#define toggle(reg,bit)		reg ^= (1<<(bit))
#define check(reg,bit)		(bool)(reg & (1<<(bit)))


// I2C slave status codes:
// transmit:
#define TX_ADDR_ACK          0xA8  // received our address + read bit and ACK'd
#define TX_ADDR_ACK_ARB_LOST 0xB0  // received our address + read bit and ACK'd, also master arbitration was lost
#define TX_BYTE_ACK          0xB8  // sent the byte in TWDR and got an ACK
#define TX_BYTE_NACK         0xC0  // sent the byte in TWDR and got a NACK
#define TX_FINAL_BYTE_ACK    0xC8  // sent the last byte in TWDR and got an ACK

// receive:
#define RX_ADDR_ACK          0x60  // received our address + write bit and ACK'd
#define RX_ADDR_ACK_ARB_LOST 0x68  // received our address + write bit and ACK'd, also master arbitration was lost
#define RX_GEN_ACK           0x70  // received general call address and ACK'd
#define RX_GEN_ACK_ARB_LOST  0x78  // received general call address and ACK'd, also master arbitration was lost
#define RX_ADDR_DATA_ACK     0x80  // received data on our address and ACK'd
#define RX_ADDR_DATA_NACK    0x88  // received data on our address and NACK'd
#define RX_GEN_DATA_ACK      0x90  // received data on general call address and ACK'd
#define RX_GEN_DATA_NACK     0x98  // received data on general call address and NACK'd
#define RX_STOP_RESTART      0xA0  // received a STOP or repeated START condition

// other:
#define I2C_UNDEFINED        0xF8  // no state information available
#define I2C_ERROR            0x00  // an error occurred on the I2C bus


typedef enum m_microsd_command_type
{
    M_SD_INIT = 0,
    M_SD_SHUTDOWN,
    M_SD_GET_SIZE,
    M_SD_OBJECT_EXISTS,
    M_SD_GET_FIRST_ENTRY,
    M_SD_GET_NEXT_ENTRY,
    M_SD_PUSH,
    M_SD_POP,
    M_SD_MKDIR,
    M_SD_RMDIR,
    M_SD_DELETE,
    M_SD_OPEN,
    M_SD_CLOSE,
    M_SD_SEEK,
    M_SD_GET_SEEK,
    M_SD_READ,
    M_SD_WRITE,
    
    M_SD_NONE = 255
} m_microsd_command_type;


typedef struct i2c_command
{
    uint8_t command;
    uint8_t data_length;
    uint8_t data[TWI_BUFFER_LEN];
} i2c_command;

typedef struct i2c_response
{
    uint8_t response_code;
    uint8_t data_length;
    uint8_t data[TWI_BUFFER_LEN];
} i2c_response;

volatile i2c_command  order;
volatile i2c_response response;


#ifdef TEST_FAT32

// TEST: Copy testdir/python.txt into both
//       testdir/created/py_copy.txt and testdir/created/py_copy2.txt

static void error (void)
{
    for (;;)
    {
        toggle (PORTB, 0);
        _delay_ms (125);
    }
}

#define COPY_BUFFER_LEN 80
uint8_t copy_buffer[COPY_BUFFER_LEN];

static void test_copy (void)
{
    if (!sd_fat32_init())
        error();
    
    if (!sd_fat32_push ("testdir"))
        error();
    
    uint32_t file_size;
    if (!sd_fat32_get_size ("python.txt", &file_size))
        error();
    
    uint32_t bytes_copied = 0;
    
    while (bytes_copied < file_size)
    {
        uint32_t bytes_to_copy = file_size - bytes_copied;
        if (bytes_to_copy > COPY_BUFFER_LEN)
            bytes_to_copy = COPY_BUFFER_LEN;
        
        if (!sd_fat32_open_file ("python.txt", READ_FILE))
            error();
        
        if (!sd_fat32_seek (bytes_copied))
            error();
        
        if (!sd_fat32_read_file (bytes_to_copy, copy_buffer))
            error();
        
        if (!sd_fat32_push ("created"))
            error();
        
        const open_option open_type = (bytes_copied == 0) ? CREATE_FILE : APPEND_FILE;
        if (!sd_fat32_open_file ("py_copy.txt", open_type))
            error();
        
        if (!sd_fat32_write_file (bytes_to_copy, copy_buffer))
            error();
        
        if (!sd_fat32_open_file ("py_copy2.txt", open_type))
            error();
        
        if (!sd_fat32_write_file (bytes_to_copy, copy_buffer))
            error();
        
        if (!sd_fat32_pop ())
            error();
        
        bytes_copied += bytes_to_copy;
    }
    
    if (!sd_fat32_shutdown())
        error();
}

#endif



inline void reset_i2c (void)
{  // enable I2C, enable ACKs, and clear the interrupt flag
    TWCR = _BV (TWEN) | _BV (TWEA) | _BV (TWINT);
}

inline uint8_t wait_for_interrupt (void)
{  // returns the transfer status
    reset_i2c();
    while (!check (TWCR, TWINT));  // wait for an interrupt
    return TWSR & 0b11111000;  // ignore the prescaler bits of the status register
}

bool i2c_read_bytes (const uint8_t num_bytes,
                     uint8_t *buffer)
{
    uint8_t status;
    uint8_t bytes_read = 0;
    
    status = wait_for_interrupt();
    
    // the first thing we expect is our address
    if (status != RX_ADDR_ACK && status != RX_ADDR_ACK_ARB_LOST)
    {
        reset_i2c();
        return false;
    }
    
    while (bytes_read < num_bytes)
    {
        status = wait_for_interrupt();
        
        // the next thing we expect is a byte of data
	    if (status != RX_ADDR_DATA_ACK)
	    {
		    reset_i2c();
		    return false;
	    }
	    buffer[bytes_read++] = TWDR;
	}
	
	status = wait_for_interrupt();
    
    // we now expect a STOP
    if (status != RX_STOP_RESTART)
    {
        reset_i2c();
        return false;
    }
    
    reset_i2c();
    return true;
}

uint8_t num_received = 0;
bool i2c_receive (void)
{
    return i2c_read_bytes (1, &num_received);
}

bool i2c_send (const uint8_t length,
               const uint8_t *buffer)
{
    uint8_t status;
    uint8_t bytes_sent = 0;
    
    status = wait_for_interrupt();
    
    // the first thing we expect is our address
    if (status != TX_ADDR_ACK && status != TX_ADDR_ACK_ARB_LOST)
    {
        reset_i2c();
        return false;
    }
    
    while (bytes_sent < num_bytes)
    {
        TWDR = buffer[bytes_sent++];
        status = wait_for_interrupt();
        
        // the next thing we expect is a byte of data
	    if (status != TX_BYTE_ACK)
	    {
		    reset_i2c();
		    return false;
	    }
	}
	
	reset_i2c();
    return true;
}




void main (void)
{
    // set the clock divider to 1, for 8 MHz
    CLKPR = (1<<CLKPCE);
    CLKPR = 0;
    
    
    #ifdef TEST_FAT32
    // test the FAT32 interface and then busy-loop
    // LED on: still working
    // LED off: done
    // LED blinking: error
    set (DDRB, 0);
    set (PORTB, 0);
    test_copy();
    clear (PORTB, 0);
    for (;;);
    #endif
    
    
    // set up I2C:
    
    // I2C frequency = CPU clock / (16 + (2 * TWBR * prescaler))
    // we want a 400 kHz frequency: prescaler = 1, TWBR = 2
    
    // set prescaler to 1 and TWBR to 2
    clear (TWSR, TWPS0);
    clear (TWSR, TWPS1);
    TWBR = 2;
    
    // set slave address, and don't listen to the general call address
    TWAR = (I2C_ADDR << 1) & 0xfe;
    
    set (TWCR, TWEA);   // enable ACKs
    set (TWCR, TWIE);   // enable I2C interrupts
    set (TWCR, TWINT);  // clear the I2C interrupt
    set (TWCR, TWEN);   // enable I2C
    
    sei();
    
    
    
    
    for (;;)
    {
        // process any commands received over I2C
        
        i2c_receive();  // block until we receive a command
        num_received++;
        
        //if (!do_command())
            i2c_send (1, &num_received);
        //else
        //    i2c_send (
    }
}

