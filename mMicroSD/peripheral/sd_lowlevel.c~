#include "sd_lowlevel.h"

#ifdef LOWLEVEL_DEBUG
#include "m_usb.h"

uint32_t total_block_accesses = 0;
#endif


#ifdef _AVR_IOM32U4_H_
// running on the M2

#define POWER_REDUCTION_REGISTER PRR0

#define P_SS   PORTB0
#define P_SCLK PORTB1
#define P_MOSI PORTB2
#define P_MISO PORTB3

#else
// running on the ATmega168/328

#define POWER_REDUCTION_REGISTER PRR

#define P_SS   PORTB2
#define P_SCLK PORTB5
#define P_MOSI PORTB3
#define P_MISO PORTB4

#endif


// M4 pins:
//    SS: (arbitrary) B1
//    SCLK: A5
//    MOSI: B0
//    MISO: A6


#define SS_HIGH() set   (PORTB, P_SS)
#define SS_LOW()  clear (PORTB, P_SS)


#define CMD_RESET          0
#define CMD_INIT           1
#define CMD_CHECK_VOLTAGE  8
#define CMD_BLOCK_LENGTH   16
#define CMD_READ_BLOCK     17
#define CMD_WRITE_BLOCK    24
#define CMD_SD_INIT        41
#define CMD_APP_CMD        55
#define CMD_READ_OCR       58
#define CMD_CRC_ON_OFF     59

bool is_sdhc = false;
bool crc_enabled = false;

uint16_t last_crc = 0;  // the most recently received CRC value from the card
// (needed because the card could be returning all 0xFFFFs instead of actual CRCs)

void write_SPI_byte (uint8_t byte)
{
    SPDR = byte;  // send the byte to the output register
    while (!check (SPSR, SPIF));  // wait for it to be written out
    clear (SPSR, SPIF);
}

uint8_t read_SPI_byte()
{
    SPDR = 0xff;  // send dummy data
    while(!check (SPSR, SPIF));
    clear (SPSR, SPIF);
    return SPDR;
}

void attempt_resync (void)
{
    SS_HIGH();
    read_SPI_byte();
    SS_LOW();
    uint16_t byte_counter = 0;
    while (read_SPI_byte() != (uint8_t)0xff || byte_counter < 65535)
        byte_counter++;
    SS_HIGH();
}

uint8_t send_SD_command (uint8_t command, const uint32_t data)
{
    uint8_t message[6];
    message[0] = 0b01000000 | command;
    message[1] = (data >> 24) & 0xff;
    message[2] = (data >> 16) & 0xff;
    message[3] = (data >> 8)  & 0xff;
    message[4] =  data        & 0xff;
    
    if (command == CMD_RESET)
        message[5] = 0x95;  // need a valid CRC when saying "go to SPI mode"
    else if (command == CMD_CHECK_VOLTAGE)
        message[5] = 0x87;  // also need a valid CRC for the voltage check command
    else if (command == CMD_CRC_ON_OFF || crc_enabled)
        message[5] = (getCRC (message, 5) << 1) | 0x01;
    else
        message[5] = 0xff;  // dummy CRC byte
    
    
    SS_HIGH();
    write_SPI_byte (0xff);  // give the card some breathing room between commands
    SS_LOW();
    
    for (uint8_t i = 0; i < 6; i++)
        write_SPI_byte (message[i]);
    
    // need to send an additional 8 clock cycles after a command
    // but give it 10 bytes' worth to see if it sends a response
    uint8_t response = 0xff;
    for (uint8_t i = 0; i < 10 && response == 0xff; i++)
        response = read_SPI_byte();
    
    SS_HIGH();
    
    return response;
}

ret reset_card (void)
{
    crc_enabled = false;
    uint8_t response;
    
    // give the SD card 80 clock cycles to start up (with SS and MOSI high)
    SS_HIGH();
    set (PORTB, P_MOSI);
    
    for (uint8_t i = 0; i < 10; i++)
        read_SPI_byte();
    
    // try several times before giving up
    for (uint16_t i = 0; i < RESET_TRIES_BEFORE_ERROR; i++)
    {
        response = send_SD_command (CMD_RESET, 0);
        
        if (response == 1)  // got the expected response
            return OK;
        
        // give it a few clock cycles
        for (uint8_t rest = 0; rest < 5; rest++)
            write_SPI_byte (0xff);
    }
    
    return ERROR;  // failure
}

ret enable_crc (void)
{
    const uint8_t response = send_SD_command (CMD_CRC_ON_OFF, 1);
    
    if (response == 0 || response == 1)
    {
        crc_enabled = true;
        return OK;
    }
    
    return ERROR;
}

int8_t voltage_command (void)
{
    uint8_t voltage_response = send_SD_command (CMD_CHECK_VOLTAGE, 0x1aa);
    
    if (voltage_response == 1)
    {  // the card returned OK, and will send an additional 4 bytes
        SS_LOW();
        read_SPI_byte();
        read_SPI_byte();
        uint8_t byte1 = read_SPI_byte();
        uint8_t byte2 = read_SPI_byte();
        SS_HIGH();
        
        if (byte1 != 0x01 || byte2 != 0xaa)
        {  // invalid data returned
            return -1;  // bad response: we can't use the card at all in this case
        }
        return 1;  // indicate SDHC card
    }
    else
    {  // the card returned "invalid command"
        SS_LOW();
        while (voltage_response != 0xff)
        {  // it might return a bunch of nonsense, wait until it's done
            voltage_response = read_SPI_byte();
        }
        SS_HIGH();
        
        return 0;  // indicate SD card
    }
}

void check_sdhc_blocksize (void)
{  // cards that respond to an SDHC init might still use SD block addressing
    if (send_SD_command (CMD_READ_OCR, 0) != 0)  // card responded with an error
        is_sdhc = false;
    
    // if no error, the card sends 4 more bytes
    
    SS_LOW();
    
    // the second most significant bit of the first byte indicates addressing type
    if ((read_SPI_byte() & 0x40) == 0)
        is_sdhc = false;
    
    // read the other, unused, bytes
    read_SPI_byte();
    read_SPI_byte();
    read_SPI_byte();
    
    SS_HIGH();
    
    #ifdef LOWLEVEL_DEBUG
    if (is_sdhc)
        m_usb_tx_string ("Card uses SDHC addressing\n");
    else
        m_usb_tx_string ("Card uses SD addressing\n");
    #endif
}

ret initialize_card (void)
{
    uint8_t response;
    
    #ifdef LOWLEVEL_DEBUG
    m_usb_tx_string ("Initializing\n");
    #endif
    
    int8_t voltage_response = voltage_command();
    
    #ifdef LOWLEVEL_DEBUG
    m_usb_tx_string ("Voltage response: ");
    m_usb_tx_int (voltage_response);
    m_usb_tx_string ("\n");
    #endif
    
    if (voltage_response == -1)
    {  // bad voltage response, don't use the card
        return ERROR;
    }
    
    if (voltage_response == 1)
    {  // SDHC card
        is_sdhc = true;
        
        #ifdef LOWLEVEL_DEBUG
        m_usb_tx_string ("SDHC init\n");
        #endif
        for (uint16_t tries = 0; tries < INIT_TRIES_BEFORE_ERROR; tries++)
        {
            send_SD_command (CMD_APP_CMD, 0);  // prepare for special init command
            
            // send init command with the HCS flag (indicates host SDHC support)
            response = send_SD_command (CMD_SD_INIT, 0x40000000);
            
            if (response == 0)  // success
            {
                #ifdef LOWLEVEL_DEBUG
                m_usb_tx_string ("success\n");
                #endif
                
                check_sdhc_blocksize();  // check whether SDHC addressing is actually used
                
                return OK;
            }
            
            if (response == 1)  // card is still busy
                continue;
            
            // any other response: encountered an error
            #ifdef LOWLEVEL_DEBUG
            m_usb_tx_string ("error\n");
            #endif
            break;
        }
    }
    
    
    // if we reached this point, the card is non-SDHC
    #ifdef LOWLEVEL_DEBUG
    m_usb_tx_string ("SD init\n");
    #endif
    uint16_t tries = 0;
    while (1)
    {
        tries++;
        
        if (tries > INIT_TRIES_BEFORE_ERROR)
            return TIMEOUT;
        
        send_SD_command (CMD_APP_CMD, 0);  // prepare for special init command
        response = send_SD_command (CMD_SD_INIT, 0);  // send init command
        
        if (response == 0)  // success
            return OK;
        
        if (response == 1)  // card is still busy
            continue;
        
        // any other response: error
        // try CMD_INIT without the prepended CMD_ACMD
        tries /= 2;  // give it a few more tries to work with
        break;
    }
    
    while (1)
    {  // ACMD41 failed, try regular CMD1 initialization
        tries++;
        
        if (tries > INIT_TRIES_BEFORE_ERROR)
            return TIMEOUT;
        
        response = send_SD_command (CMD_INIT, 0);
        
        if (response == 0)  // success
            return OK;
        
        if (response == 1)  // card is still busy
            continue;
        
        // any other response: error
        return ERROR;
    }
    
    return OK;
}


volatile uint8_t block[MAX_BLOCK_LENGTH];
uint16_t block_length = 0;

ret set_block_length (const uint16_t new_block_length)
{
    if (new_block_length > MAX_BLOCK_LENGTH)
        return ERROR;
    
    const uint8_t response = send_SD_command (CMD_BLOCK_LENGTH, new_block_length);
    
    if (response == 0)
    {
        block_length = new_block_length;
        return OK;
    }
    return ERROR;
}

ret read_block (const uint32_t block_number)
{
    // SD cards take the direct address of the block
    // SDHC cards take the block number
    
    #ifdef FREE_RAM
    free_ram();
    #endif
    
    #ifdef LOWLEVEL_DEBUG
    total_block_accesses++;
    
    if (is_sdhc)
        m_usb_tx_string ("SDHC");
    else
        m_usb_tx_string ("SD");
    
    m_usb_tx_string (" read: block number = ");
    m_usb_tx_uint (block_number);
    m_usb_tx_char ('\n');
    #endif
    
    uint8_t response = send_SD_command (CMD_READ_BLOCK, (is_sdhc) ? block_number : block_number * (uint32_t)512);
    uint16_t emptyBytes = 0;
    
    uint16_t crc = 0;
    uint16_t sent_crc;
    
    SS_LOW();
    while (response == 0xff ||
           response == 0x00)
    {  // waiting for a response
        emptyBytes++;
        
        if (emptyBytes >= READ_BLOCK_TIMEOUT_BYTES)  // we've waited long enough
        {
            #ifdef LOWLEVEL_DEBUG
            m_usb_tx_string ("Error: timeout\n");
            #endif
            return TIMEOUT;  // give up
        }
        
        response = read_SPI_byte();
    }
    SS_HIGH();
    
    if (response != 0xfe)
    {
        #ifdef LOWLEVEL_DEBUG
        m_usb_tx_string ("Error: response = ");
        m_usb_tx_hex (response & (uint16_t)0xff);
        m_usb_tx_char ('\n');
        #endif
        return ERROR;  // the result was an error byte, not a data token
    }
    
    // all clear, begin reading
    SS_LOW();
    
    for (uint16_t i = 0; i < block_length; i++)
        block[i] = read_SPI_byte();
    
    if (!crc_enabled)
    {
        read_SPI_byte();  // 16-bit CRC
        read_SPI_byte();
        
        SS_HIGH();
    }
    else
    {
        sent_crc = read_SPI_byte();
        sent_crc <<= 8;
        sent_crc |= read_SPI_byte();
        
        last_crc = sent_crc;
        crc = crc16_ccitt (block, block_length);
        
        SS_HIGH();
        
        #ifdef LOWLEVEL_DEBUG
        m_usb_tx_string ("Calculated hex: ");
        m_usb_tx_hex (crc);
        m_usb_tx_char ('\n');
        m_usb_tx_string ("Received hex:   ");
        m_usb_tx_hex (sent_crc);
        m_usb_tx_char ('\n');
        #endif
        
        if (crc != sent_crc)
        {
            return BAD_CRC;
        }
    }
    
    #ifdef LOWLEVEL_DEBUG
    m_usb_tx_string ("Read complete\n");
    #endif
    
    return OK;
}

ret read_block_crc_only (const uint32_t block_number, uint16_t *crc)
{
    // read the CRC for the block, but don't touch the data in block[]
    
    // SD cards take the direct address of the block
    // SDHC cards take the block number
    
    #ifdef FREE_RAM
    free_ram();
    #endif
    
    #ifdef LOWLEVEL_DEBUG
    total_block_accesses++;
    
    if (is_sdhc)
        m_usb_tx_string ("SDHC");
    else
        m_usb_tx_string ("SD");
    
    m_usb_tx_string (" read crc: block number = ");
    m_usb_tx_uint (block_number);
    m_usb_tx_char ('\n');
    #endif
    
    uint8_t response = send_SD_command (CMD_READ_BLOCK, (is_sdhc) ? block_number : block_number * (uint32_t)512);
    uint16_t emptyBytes = 0;
    
    uint16_t sent_crc;
    
    SS_LOW();
    while (response == 0xff ||
           response == 0x00)
    {  // waiting for a response
        emptyBytes++;
        
        if (emptyBytes >= READ_BLOCK_TIMEOUT_BYTES)  // we've waited long enough
        {
            #ifdef LOWLEVEL_DEBUG
            m_usb_tx_string ("Error: timeout\n");
            #endif
            return TIMEOUT;  // give up
        }
        
        response = read_SPI_byte();
    }
    SS_HIGH();
    
    if (response != 0xfe)
    {
        #ifdef LOWLEVEL_DEBUG
        m_usb_tx_string ("Error: response = ");
        m_usb_tx_hex (response & (uint16_t)0xff);
        m_usb_tx_char ('\n');
        #endif
        return ERROR;  // the result was an error byte, not a data token
    }
    
    // all clear, begin reading
    SS_LOW();
    
    *crc = 0;
    for (uint16_t i = 0; i < block_length; i++)
    {
        uint8_t byte = read_SPI_byte();
        crc16_by_byte (crc, byte);
    }
    
    if (!crc_enabled)
    {
        read_SPI_byte();  // 16-bit CRC
        read_SPI_byte();
        
        SS_HIGH();
    }
    else
    {
        sent_crc = read_SPI_byte();
        sent_crc <<= 8;
        sent_crc |= read_SPI_byte();
        
        SS_HIGH();
        
        #ifdef LOWLEVEL_DEBUG
        m_usb_tx_string ("Calculated hex: ");
        m_usb_tx_hex (*crc);
        m_usb_tx_char ('\n');
        m_usb_tx_string ("Received hex:   ");
        m_usb_tx_hex (sent_crc);
        m_usb_tx_char ('\n');
        #endif
        
        if (*crc != sent_crc)
        {
            return BAD_CRC;
        }
    }
    
    #ifdef LOWLEVEL_DEBUG
    m_usb_tx_string ("Read complete\n");
    #endif
    
    return OK;
}

ret write_block (const uint32_t block_number)
{
    uint16_t crc;
    
    #ifdef FREE_RAM
    free_ram();
    #endif
    
    #ifdef LOWLEVEL_DEBUG
    total_block_accesses++;
    
    if (is_sdhc)
        m_usb_tx_string ("SDHC");
    else
        m_usb_tx_string ("SD");
    
    m_usb_tx_string (" write, block ");
    m_usb_tx_uint (block_number);
    m_usb_tx_string (", data = ");
    m_usb_tx_char ('\n');
    
    for (uint16_t i = 0; i < 512; i++)
    {
        if (i % 16 == 0)
            m_usb_tx_char ('\n');
        m_usb_tx_hexchar (block[i]);
        m_usb_tx_char (' ');
    }
    m_usb_tx_char ('\n');
    
    #endif
    
    if (crc_enabled)
    {
        crc = crc16_ccitt (block, block_length);
        
        #ifdef LOWLEVEL_DEBUG
        m_usb_tx_string ("Sent CRC: ");
        m_usb_tx_hex (crc);
        m_usb_tx_char ('\n');
        #endif
    }
    else
    {
        crc = 0xffff;
    }
    
    // SD cards take the direct address of the block
    // SDHC cards take the block number
    uint8_t response = send_SD_command (CMD_WRITE_BLOCK, (is_sdhc) ? block_number : block_number * 512);
    if (response != 0)
    {
        #ifdef LOWLEVEL_DEBUG
        m_usb_tx_string ("Error: response = ");
        m_usb_tx_hex (response & (uint16_t)0xff);
        m_usb_tx_char ('\n');
        #endif
        return ERROR;
    }
    
    SS_LOW();
    read_SPI_byte();
    
    // send the start data token
    write_SPI_byte (0xfe);
    
    // send the data
    for (uint16_t i = 0; i < block_length; i++)
        write_SPI_byte (block[i]);
    
    // send 16-bit CRC
    write_SPI_byte ((crc >> 8) & 0xff);
    write_SPI_byte (crc & 0xff);
    
    // read data response
    response = read_SPI_byte() & 0b00001111;
    
    // continue reading until SD card stops sending a busy signal
    while (read_SPI_byte() != 0xff);
    
    SS_HIGH();
    
    if (response == 0b1101)  // write error
    {
        #ifdef LOWLEVEL_DEBUG
        m_usb_tx_string ("Write error\n");
        #endif
        return ERROR;
    }
    if (response == 0b1011)  // CRC error
    {
        #ifdef LOWLEVEL_DEBUG
        m_usb_tx_string ("Write error\n");
        #endif
        return BAD_CRC;
    }
    if (response == 0b0101)  // data accepted
    {
        #ifdef LOWLEVEL_DEBUG
        m_usb_tx_string ("Write complete\n");
        #endif
        return OK;
    }
    
    // continue reading until SD card stops sending a busy signal
    SS_LOW();
    while (read_SPI_byte() != 0xff);
    SS_HIGH();
    
    // the response should be one of those three, so we should never get here
    #ifdef LOWLEVEL_DEBUG
    m_usb_tx_string ("Write error\n");
    #endif
    return ERROR;
}

void start_spi (enum spi_speed speed)
{
    clear (POWER_REDUCTION_REGISTER, PRSPI);  // disable SPI power reduction
    
    set   (DDRB, P_SS);    // set B0 (SS) as output
    set   (DDRB, P_SCLK);  // set B1 (SCLK) as output
    set   (DDRB, P_MOSI);  // set B2 (MOSI) as output
    clear (DDRB, P_MISO);  // set B3 (MISO) as input
    
    clear (PORTB, P_MISO); // disable pull-up resistor on MISO
    set   (PORTB, P_MOSI); // initialize MOSI high
    clear (PORTB, P_SCLK); // initialize SCLK low
    SS_HIGH();             // initialize SS high
    
    switch (speed)
    {
        case SPI_INIT_SPEED:
            // set SPI clock to /64, SPI2X disabled
            // SPI clock is 125kHz at 8MHz (ATmega168/328) or 250kHz at 16Mhz
            // (valid clock speeds for the initial SPI setup are 100-400kHz)
            clear (SPCR, SPR0);
            set   (SPCR, SPR1);
            clear (SPSR, SPI2X);
            break;
        case SPI_MIN_SPEED:
            // set SPI to the lowest speed we deem acceptable
            // SPI clock divider at /16, SPI2x disabled
            // final speed: 500kHz at 8Mhz or 1MHz at 16Mhz
            set   (SPCR, SPR0);
            clear (SPCR, SPR1);
            clear (SPSR, SPI2X);
            break;
        case SPI_LOW_SPEED:
            // set SPI to a low speed: SPI clock divider at /16, SPI2X enabled
            // final speed: 1MHz or 2MHz
            set   (SPCR, SPR0);
            clear (SPCR, SPR1);
            set   (SPSR, SPI2X);
            break;
        case SPI_MED_SPEED:
            // set SPI to a medium speed: SPI clock divider at /4, SPI2X disabled
            // final speed: 2MHz or 4MHz
            clear (SPCR, SPR0);
            clear (SPCR, SPR1);
            clear (SPSR, SPI2X);
            break;
        case SPI_HIGH_SPEED:
            // set SPI to max speed: SPI clock divider at /4, SPI2X enabled
            // final speed: 4MHz
            clear (SPCR, SPR0);
            clear (SPCR, SPR1);
            set   (SPSR, SPI2X);
            break;
    }
    
    set (SPCR, SPE);   // enable SPI
    set (SPCR, MSTR);  // set SPI to master mode
}




